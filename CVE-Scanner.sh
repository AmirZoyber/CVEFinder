#!/usr/bin/env bash
# CVE-Scanner.sh / service-scanner.sh
# masscan/nmap wrapper with per-port nmap -sV enumeration + optional CVE lookup via searchsploit
# - Multi-targets (IPv4/IPv6/CIDR/range/domain/URL) + -iL
# - URL/hostname normalization (strip scheme, path, port), root-domain detection
# - Subfinder mode (--subfinder) and *prompt that really pauses*, even under sudo (/dev/tty)
# - For domain targets: masscan on resolved IPs; nmap discovery on the hostname (-sT/-sU)
# - Clean logs, deduped per-target summaries, optional CVE workflow + webanalyze on (sub)domains
set -euo pipefail

# -----------------------
# Load config
# -----------------------
CONFIGFILE="./config.conf"
if [ ! -f "$CONFIGFILE" ]; then
  echo "[!] Missing config file: $CONFIGFILE"
  echo "    Copy the provided config.conf into the script directory and edit as needed."
  exit 1
fi
# shellcheck source=/dev/null
. "$CONFIGFILE"

# -----------------------
# Validate expected config variables exist (fail early if missing)
# -----------------------
_required_vars=(TARGET DO_TCP DO_UDP OUTFILE SCILENT KEEP_TMP DEBUG RATE PORTS_SPEC PORT_SCAN_FLAG SERVICE_SCAN_FLAG MASSCAN_FIRST WEBANALYZE_APP_JSON RUN_WEBANALYZE_ALWAYS PORTS_TCP PORTS_UDP)
_missing=()
for v in "${_required_vars[@]}"; do
  if ! eval "[ \"\${${v}+defined}\" ]"; then
    _missing+=("$v")
  fi
done
if [ "${#_missing[@]}" -ne 0 ]; then
  echo "[!] The following config variables are missing in $CONFIGFILE:"
  for m in "${_missing[@]}"; do echo "    - $m"; done
  exit 2
fi
unset _required_vars _missing m v

# -----------------------
# Logging (timestamps + categories + symbols + optional colors)
# -----------------------
_ts() { date +"%Y-%m-%d %H:%M:%S"; }

_supports_color=false
if [ -t 2 ] && command -v tput >/dev/null 2>&1; then
  if [ "${NO_COLOR:-}" = "" ] && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
    _supports_color=true
  fi
fi

if [ "$_supports_color" = true ]; then
  C_RST="$(tput sgr0)"; C_OK="$(tput setaf 2)"; C_INF="$(tput setaf 6)"; C_WRN="$(tput setaf 3)"; C_ERR="$(tput setaf 1)"; C_DBG="$(tput setaf 8)"
else
  C_RST=""; C_OK=""; C_INF=""; C_WRN=""; C_ERR=""; C_DBG=""
fi

_log_core() { printf "%s %s%s%s %s\n" "$(_ts)" "$3" "$2" "$C_RST" "$4" >&2; }
log_ok()   { _log_core OK  "[+]" "$C_OK"  "$*"; }
log_info() { _log_core INF "[*]" "$C_INF" "$*"; }
log_warn() { _log_core WRN "[!]" "$C_WRN" "$*"; }
log_err()  { _log_core ERR "[x]" "$C_ERR" "$*"; }
log_dbg()  { [ "${DEBUG:-false}" = "true" ] && _log_core DBG "[·]" "$*"; }
die() { log_err "$*"; exit 1; }

# -----------------------
# Helpers
# -----------------------
check_installed() { which "$1" >/dev/null 2>&1; }
sanitize() { printf "%s" "$1" | sed -E 's/[^A-Za-z0-9_.-]+/_/g'; }
_printf_safe() { printf "%s" "$1"; }

# Always-blocking prompt (works under sudo/pipes). Usage: ans=$(prompt_read "Question: ")
prompt_read() {
  local _p="$1" _ans=""
  # print prompt to stderr (so stdout stays clean)
  _printf_safe "$_p" >&2
  if [ -t 0 ]; then
    IFS= read -r _ans
  elif [ -r /dev/tty ]; then
    IFS= read -r _ans < /dev/tty
  else
    _ans=""
  fi
  printf "%s" "$_ans"
}

print_help() {
  cat <<'EOF'
  service-scanner.sh - Port discovery + per-port service enumeration with nmap (+ optional CVE lookup)

  Usage: ./service-scanner.sh [targets/options]

  Targets:
    -t, --target <target>    One target (IPv4/IPv6/CIDR/range/domain/URL). You can repeat -t.
    -iL <file>               Read targets from file (one per line; commas/whitespace ok)

  Modes / Options (CLI overrides config.conf):
    -T                       Scan TCP
    -U                       Scan UDP
    -TU                      Scan both TCP and UDP
    -p, --ports <spec>       Port spec, e.g. "80,443,8000-8100"
    --rate <n>               masscan --rate
    --port-scan              Discovery only
    --service-scan           Discovery + per-port nmap -sV
    --cve                    Same as --service-scan + interactive searchsploit (CVE) by chosen services
    --subfinder              Subdomain mode:
                               • Alone: only subdomain enumeration (with IP->domain mapping), then exit
                               • With scan modes: enumerate first, add all subs to targets, then scan
    --keep-tmp               Keep tmp directory after run
    --debug                  Verbose logs (implies --keep-tmp)
    -o, --output <file>      Save combined final port list (host port/proto)
    -s, --scilence           Do not print open-port lists to stdout
    -h, --help               Show this help

  Notes:
    - For domain/URL targets: masscan runs on resolved IPs; nmap discovery runs on the hostname (-sT/-sU).
    - IP→Domain mapping is attempted via PTR for single IPs when --subfinder is set.
EOF
}

# Normalize any target to a plain hostname (strip scheme, creds, path, port, [] for IPv6)
normalize_host() {
  local s="$1"
  s="$(printf "%s" "$s" | tr '[:upper:]' '[:lower:]')"
  s="$(printf "%s" "$s" | sed -E 's#^[[:space:]]*(https?://)##I')"     # strip scheme
  s="$(printf "%s" "$s" | sed -E 's#^[^/@]+@##')"                      # strip creds
  s="${s%%/*}"                                                         # strip path/query/fragment
  s="$(printf "%s" "$s" | sed -E 's#^\[##; s#\]$##')"                  # strip [IPv6]
  s="$(printf "%s" "$s" | sed -E 's#:[0-9]+$##')"                      # strip :port
  s="$(printf "%s" "$s" | sed -E 's#\.$##')"                           # strip trailing dot
  printf "%s" "$s"
}

# Return the registrable (apex) domain via heuristics (handles common 2-level TLDs)
get_root_domain() {
  local h lc
  h="$(normalize_host "$1")"
  lc="$(printf "%s" "$h" | tr '[:upper:]' '[:lower:]')"
  [ -z "$lc" ] && return 1
  # If it's an IP (v4/v6), no root domain
  if printf "%s" "$lc" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then return 1; fi
  if printf "%s" "$lc" | grep -Eq '^[0-9a-f:]+$' && printf "%s" "$lc" | grep -q ':'; then return 1; fi

  IFS='.' read -r -a parts <<< "$lc"
  local n="${#parts[@]}"
  [ "$n" -lt 2 ] && return 1

  local sld='(co\.uk|org\.uk|gov\.uk|ac\.uk|sch\.uk|com\.au|net\.au|org\.au|edu\.au|gov\.au|co\.jp|ne\.jp|or\.jp|ac\.jp|go\.jp)'
  if printf "%s" "$lc" | grep -Eq "\.${sld}$"; then
    if [ "$n" -ge 3 ]; then
      printf "%s.%s.%s" "${parts[$((n-3))]}" "${parts[$((n-2))]}" "${parts[$((n-1))]}"
      return 0
    else
      printf "%s.%s" "${parts[$((n-2))]}" "${parts[$((n-1))]}"
      return 0
    fi
  fi
  printf "%s.%s" "${parts[$((n-2))]}" "${parts[$((n-1))]}"
  return 0
}

is_ipv4() { printf "%s" "$1" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; }
is_ipv6() { printf "%s" "$1" | grep -Eq '^[0-9A-Fa-f:]+$' && echo "$1" | grep -q ':'; }
is_cidr() { printf "%s" "$1" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$|^[0-9A-Fa-f:]+/[0-9]{1,3}$'; }
is_range(){ printf "%s" "$1" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}-[0-9]{1,3}$|^[0-9]{1,3}(\.[0-9]{1,3}){2}\.[0-9]{1,3}-[0-9]{1,3}$|^[0-9]{1,3}(\.[0-9]{1,3}){3}-([0-9]{1,3}\.){3}[0-9]{1,3}$'; }
is_hostname(){ printf "%s" "$1" | grep -Eq '^[A-Za-z0-9.-]+$' && echo "$1" | grep -q '[A-Za-z]'; }

# reverse DNS (single IP -> FQDNs)
reverse_dns_ip() {
  local ip="$1"
  if check_installed dig; then
    dig +short -x "$ip" 2>/dev/null | sed '/^$/d' | sed 's/\.$//' | sort -u
  elif check_installed host; then
    host "$ip" 2>/dev/null | awk '/pointer/ {print $5}' | sed 's/\.$//' | sort -u
  elif check_installed getent; then
    getent hosts "$ip" 2>/dev/null | awk '{print $2}' | sort -u
  else
    echo "__NO_RESOLVER__"
  fi
}

# resolve A/AAAA for hostname
resolve_ips_for_host() {
  local h="$1"
  if check_installed dig; then
    { dig +short A "$h"; dig +short AAAA "$h"; } 2>/dev/null | sed '/^$/d' | sort -u
  elif check_installed host; then
    host "$h" 2>/dev/null | awk '/has address|has IPv6 address/ {print $4}' | sort -u
  elif check_installed getent; then
    getent ahosts "$h" 2>/dev/null | awk '{print $1}' | sort -u
  else
    echo "__NO_RESOLVER__"
  fi
}

# -----------------------
# Arg parsing (CLI overrides config)
# -----------------------
TARGET="${TARGET:-}"
DO_TCP="${DO_TCP:-false}"
DO_UDP="${DO_UDP:-false}"
OUTFILE="${OUTFILE:-}"
SCILENT="${SCILENT:-false}"
KEEP_TMP="${KEEP_TMP:-false}"
DEBUG="${DEBUG:-false}"
RATE="${RATE:-10000}"
PORTS_SPEC="${PORTS_SPEC:-}"
PORT_SCAN_FLAG="${PORT_SCAN_FLAG:-false}"
SERVICE_SCAN_FLAG="${SERVICE_SCAN_FLAG:-false}"
MASSCAN_FIRST="${MASSCAN_FIRST:-true}"
WEBANALYZE_APP_JSON="${WEBANALYZE_APP_JSON:-./technologies.json}"
RUN_WEBANALYZE_ALWAYS="${RUN_WEBANALYZE_ALWAYS:-false}"
PORTS_TCP="${PORTS_TCP:-1-65535}"
PORTS_UDP="${PORTS_UDP:-1-65535}"
CVE_FLAG="false"
IL_FILE=""
SUBFINDER_FLAG="false"

if [ $# -eq 0 ]; then print_help; exit 1; fi
while [ $# -gt 0 ]; do
  case "$1" in
    -t|--target) TARGET="${TARGET:+$TARGET }$2"; shift 2;;
    -iL) IL_FILE="$2"; shift 2;;
    -T) DO_TCP=true; shift;;
    -U) DO_UDP=true; shift;;
    -TU) DO_TCP=true; DO_UDP=true; shift;;
    -p|--ports) PORTS_SPEC="$2"; shift 2;;
    --rate) RATE="$2"; shift 2;;
    --port-scan) PORT_SCAN_FLAG=true; SERVICE_SCAN_FLAG=false; CVE_FLAG=false; shift;;
    --service-scan) SERVICE_SCAN_FLAG=true; PORT_SCAN_FLAG=false; shift;;
    --cve) CVE_FLAG=true; SERVICE_SCAN_FLAG=true; PORT_SCAN_FLAG=false; shift;;
    --subfinder) SUBFINDER_FLAG=true; shift;;
    --keep-tmp) KEEP_TMP=true; shift;;
    --debug) DEBUG=true; KEEP_TMP=true; shift;;
    -o|--output) OUTFILE="$2"; shift 2;;
    -s|--scilence) SCILENT=true; shift;;
    -h|--help) print_help; exit 0;;
    *) log_err "Unknown option/arg: $1"; print_help; exit 2;;
  esac
done

# Defaults
if [ -n "$PORTS_SPEC" ]; then PORTS_TCP="$PORTS_SPEC"; PORTS_UDP="$PORTS_SPEC"; fi
if [ "$DO_TCP" != "true" ] && [ "$DO_UDP" != "true" ]; then
  if [ "$PORT_SCAN_FLAG" = "true" ]; then DO_TCP=true; DO_UDP=true; else DO_TCP=true; fi
fi
if [ "$SERVICE_SCAN_FLAG" = "true" ] && [ "$PORT_SCAN_FLAG" = "true" ]; then
  die "Use --service-scan or --cve alone (do not combine with --port-scan)."
fi

# -----------------------
# tmpdir and cleanup
# -----------------------
TMPDIR="$(mktemp -d /tmp/svcscan.XXXXXX)"
log_dbg "TMPDIR=$TMPDIR"
cleanup() {
  if [ "$KEEP_TMP" = "true" ] && [ -d "$TMPDIR" ]; then log_info "Keeping tmp: $TMPDIR"; else rm -rf "$TMPDIR"; fi
}
trap cleanup EXIT

# -----------------------
# Target parsing / normalization
# -----------------------
ALL_INPUT_TARGETS="$TMPDIR/all_input_targets.txt"; : > "$ALL_INPUT_TARGETS"
if [ -n "${TARGET:-}" ]; then printf "%s\n" "$TARGET" | tr ' ,\t' '\n\n\n' >> "$ALL_INPUT_TARGETS"; fi
if [ -n "${IL_FILE:-}" ]; then
  if [ ! -f "$IL_FILE" ]; then die "-iL file not found: $IL_FILE"; fi
  sed 's/[[:space:]]\+/\n/g' "$IL_FILE" >> "$ALL_INPUT_TARGETS"
fi
if ! awk 'NF' "$ALL_INPUT_TARGETS" >/dev/null 2>&1; then
  die "No targets provided. Use -t/--target and/or -iL <file>."
fi

ALL_TARGETS="$TMPDIR/all_targets.txt"; : > "$ALL_TARGETS"
awk 'NF{gsub(/^[ \t]+|[ \t]+$/,""); print}' "$ALL_INPUT_TARGETS" | sed '/^$/d' | sort -u > "$ALL_TARGETS"

APEX_DOMAINS="$TMPDIR/apex_domains.txt"; : > "$APEX_DOMAINS"
HOSTNAMES_ALL="$TMPDIR/hostnames_all.txt"; : > "$HOSTNAMES_ALL"
SUBDOMAINS_FOUND="$TMPDIR/subdomains.txt"; : > "$SUBDOMAINS_FOUND"
IP_MAPPED_DOMAINS="$TMPDIR/ip_mapped_domains.txt"; : > "$IP_MAPPED_DOMAINS"

# Collect initial hostnames & apex list (normalize URLs/hosts)
while IFS= read -r tgt; do
  hn="$(normalize_host "$tgt")"
  if is_hostname "$hn"; then
    echo "$hn" >> "$HOSTNAMES_ALL"
    rd="$(get_root_domain "$hn" || true)"
    [ -n "$rd" ] && echo "$rd" >> "$APEX_DOMAINS"
  fi
done < "$ALL_TARGETS"
sort -u "$HOSTNAMES_ALL" -o "$HOSTNAMES_ALL"
sort -u "$APEX_DOMAINS"  -o "$APEX_DOMAINS"

# If --subfinder: also try IP->domain for single IPs
if [ "$SUBFINDER_FLAG" = "true" ]; then
  while IFS= read -r tgt; do
    if is_ipv4 "$tgt" || is_ipv6 "$tgt"; then
      log_info "Reverse DNS lookup for IP: $tgt"
      mapfile -t ptrs < <(reverse_dns_ip "$tgt" || true)
      if [ "${#ptrs[@]}" -eq 0 ]; then
        log_warn "$tgt: No PTR record(s) found"
      else
        if [ "${ptrs[0]}" = "__NO_RESOLVER__" ]; then
          log_warn "No resolver tools (dig/host/getent) available to resolve $tgt"
        else
          for d in "${ptrs[@]}"; do
            [ -n "$d" ] && { log_ok "$tgt -> $d"; echo "$d" >> "$IP_MAPPED_DOMAINS"; }
          done
        fi
      fi
    elif is_cidr "$tgt" || is_range "$tgt"; then
      log_warn "$tgt: CIDR/range reverse-DNS enumeration is skipped (potentially huge)."
    fi
  done < "$ALL_TARGETS"
fi

# Merge mapped domains (from IPs) into host list
if [ -s "$IP_MAPPED_DOMAINS" ]; then
  cat "$IP_MAPPED_DOMAINS" >> "$HOSTNAMES_ALL"
fi
sort -u "$HOSTNAMES_ALL" -o "$HOSTNAMES_ALL"

# Subfinder enumeration
if [ "$SUBFINDER_FLAG" = "true" ]; then
  # refresh apex list from hostnames
  : > "$APEX_DOMAINS"
  while IFS= read -r hn; do
    rd="$(get_root_domain "$hn" || true)"
    [ -n "$rd" ] && echo "$rd"
  done < "$HOSTNAMES_ALL" | sort -u > "$APEX_DOMAINS"

  if ! check_installed subfinder; then
    log_warn "subfinder not installed; skipping all subdomain enumeration"
  else
    while IFS= read -r domain; do
      [ -z "$domain" ] && continue
      log_info "subfinder -silent -d $domain"
      subfinder -silent -d "$domain" 2>/dev/null | sed '/^$/d' >> "$SUBDOMAINS_FOUND" || true
    done < "$APEX_DOMAINS"
  fi
else
  # Prompt only in service/cve modes
  if { [ "$SERVICE_SCAN_FLAG" = "true" ] || [ "$CVE_FLAG" = "true" ]; } && awk 'NF' "$HOSTNAMES_ALL" >/dev/null 2>&1; then
    ROOTS_TO_PROMPT="$TMPDIR/roots_to_prompt.txt"; : > "$ROOTS_TO_PROMPT"
    while IFS= read -r hn; do
      rd="$(get_root_domain "$hn" || true)"
      [ -n "$rd" ] && echo "$rd"
    done < "$HOSTNAMES_ALL" | sort -u > "$ROOTS_TO_PROMPT"

    while IFS= read -r domain; do
      [ -z "$domain" ] && continue
      echo
      ans="$(prompt_read "$(printf "%s [*]%s Found root domain: %s. Enumerate subdomains with subfinder? [y/N]: " "$C_INF" "$C_RST" "$domain")")"
      case "${ans:-}" in
        y|Y|yes|YES)
          if ! check_installed subfinder; then
            log_warn "subfinder not installed; skipping enumeration for $domain"
          else
            log_info "subfinder -silent -d $domain"
            subfinder -silent -d "$domain" 2>/dev/null | sed '/^$/d' >> "$SUBDOMAINS_FOUND" || true
          fi
        ;;
        *) log_info "Skipping subdomain enumeration for $domain";;
      esac
    done < "$ROOTS_TO_PROMPT"
  fi
fi

# Final hostname list: add subs if any
if [ -s "$SUBDOMAINS_FOUND" ]; then
  cat "$SUBDOMAINS_FOUND" >> "$HOSTNAMES_ALL"
  sort -u "$HOSTNAMES_ALL" -o "$HOSTNAMES_ALL"
fi

# If --subfinder only -> print & exit
if [ "$SUBFINDER_FLAG" = "true" ] && [ "$PORT_SCAN_FLAG" != "true" ] && [ "$SERVICE_SCAN_FLAG" != "true" ] && [ "$CVE_FLAG" != "true" ]; then
  echo
  echo "==== Subfinder results ===="
  if [ -s "$HOSTNAMES_ALL" ]; then
    echo "-- Hostnames (including discovered) --"
    cat "$HOSTNAMES_ALL"
  else
    echo "(no hostnames)"
  fi
  exit 0
fi

# -----------------------
# Build SCAN_TARGETS (all raw targets + all hostnames/subdomains)
# -----------------------
SCAN_TARGETS="$TMPDIR/scan_targets.txt"; : > "$SCAN_TARGETS"
cat "$ALL_TARGETS" "$HOSTNAMES_ALL" 2>/dev/null | sed '/^$/d' | sort -u > "$SCAN_TARGETS"
log_info "Targets to scan: $(wc -l < "$SCAN_TARGETS" | tr -d ' ')"
if [ "${DEBUG:-false}" = "true" ]; then nl -ba "$SCAN_TARGETS" | sed 's/^/         /'; fi

# -----------------------
# Parsers / utilities
# -----------------------
expand_ports() {
  echo "$1" | tr ',' '\n' | while read -r tok; do
    tok=$(echo "$tok" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    [ -z "$tok" ] && continue
    if echo "$tok" | grep -Eq '^[0-9]+-[0-9]+$'; then
      start=${tok%-*}; end=${tok#*-}
      if echo "$start" | grep -Eq '^[0-9]+$' && echo "$end" | grep -Eq '^[0-9]+$' && [ "$start" -le "$end" ]; then seq "$start" "$end"; fi
    else
      echo "$tok" | grep -Eq '^[0-9]+$' && echo "$tok"
    fi
  done | awk 'NF' | sort -n | uniq
}

parse_masscan_to_ports() {
  local infile="$1" out="$2" tool="${3:-masscan}" tgt="$4"
  awk '/[Dd]iscovered open port/ { for (i=1;i<=NF;i++) if ($i ~ /\/(tcp|udp)$/) print $i }' "$infile" 2>/dev/null \
    | tr -d '\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' \
    | awk -F/ '$1 ~ /^[0-9]+$/ && ($2=="tcp"||$2=="udp") {print $1"/"$2}' \
    | sort -V -u > "$out" || true
  if [ -s "$out" ]; then
    while read -r pp; do [ -z "$pp" ] && continue; log_ok "$tgt: $pp found by ${tool}"; done < "$out"
  fi
}

parse_nmap_ports() {
  local infile="$1" out="$2" tool="${3:-nmap}" tgt="$4"
  grep -E '^[[:space:]]*[0-9]+/(tcp|udp)' "$infile" 2>/dev/null \
    | awk '{gsub(/^[ \t]+/,""); print $1}' | tr -d '\r' \
    | awk -F/ '$1 ~ /^[0-9]+$/ && ($2=="tcp"||$2=="udp") {print $1"/"$2}' \
    | sort -V -u > "$out" || true
  if [ -s "$out" ]; then
    while read -r pp; do [ -z "$pp" ] && continue; log_ok "$tgt: $pp found by ${tool}"; done < "$out"
  fi
}

parse_nmap_services() {
  local infile="$1" out="$2" tool="${3:-nmap -sV}" tgt="$4"
  awk '/^[[:space:]]*[0-9]+\/(tcp|udp)/ {
    sub(/^[ \t]+/,"");
    portproto=$1; state=$2; svc=$3; banner="";
    if (portproto ~ /^PORT/) next;
    for (i=4;i<=NF;i++) banner=banner" "$i;
    gsub(/^ +| +$/,"",banner);
    if (svc == "" || svc == "unknown") next;
    printf "%s %s -> %s%s\n", "'"$tgt"'", portproto, svc, (banner ? " " banner : "")
  }' "$infile" 2>/dev/null | tr -d '\r' | sort -V -u > "$out" || true
  if [ -s "$out" ]; then
    while IFS= read -r line; do [ -z "$line" ] && continue; printf "%s\t%s\n" "$line" "$tool" >> "$SERVICE_FINDINGS_GLOBAL"; log_info "Service: $line  (${tool})"; done < "$out"
  fi
}

flatten_webanalyze_full_versions() {
  local infile="$1" outfile="$2"; : > "$outfile"
  sed '/^[[:space:]]*$/d' "$infile" \
    | grep -viE '^(https?://|url:|host:)' \
    | while IFS= read -r raw; do
        line=$(printf "%s" "$raw" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g'); [ -z "$line" ] && continue
        ver=$(printf "%s" "$line" | grep -oE '[0-9]+(\.[0-9]+)+' | head -n1 || true); [ -z "$ver" ] && continue
        printf "%s" "$line" | grep -qE 'https?://|[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' && continue
        name=$(printf "%s" "$line" | tr '_' '.' | sed -E "s/[[:space:]]+$ver.*$//" | sed -E 's/\([^)]+\)//g' | sed -E 's/^[[:space:]]+|[[:space:]]+$//g'); [ -z "$name" ] && continue
        echo "$name $ver"
      done | sort -u > "$outfile" || true
}

# -----------------------
# Runners
# -----------------------
run_masscan() {
  local target="$1" proto="$2" ports="$3" outfile="$4"; local parg
  if [ "$proto" = "udp" ]; then parg="-pU:${ports}"; else parg="-p${ports}"; fi
  log_info "masscan ${target} proto=${proto} ports=${ports} rate=${RATE}"
  if [ "$EUID" -ne 0 ]; then sudo masscan ${parg} --rate "${RATE}" "${target}" 2>&1 | tee "$outfile" >/dev/null || true
  else masscan ${parg} --rate "${RATE}" "${target}" 2>&1 | tee "$outfile" >/dev/null || true; fi
}

run_nmap_simple() {
  local target="$1" proto="$2" ports="$3" outfile="$4"
  log_info "nmap discovery ${target} proto=${proto} ports=${ports:-auto}"
  if [ "$proto" = "udp" ]; then
    if [ -n "$ports" ]; then nmap -Pn -sU -p "$ports" -oN "$outfile" "$target" >/dev/null 2>&1 || true
    else nmap -Pn -sU -oN "$outfile" "$target" >/dev/null 2>&1 || true; fi
  else
    if [ -n "$ports" ]; then nmap -Pn -sT -p "$ports" -oN "$outfile" "$target" >/dev/null 2>&1 || true
    else nmap -Pn -sT -oN "$outfile" "$target" >/dev/null 2>&1 || true; fi
  fi
}

run_nmap_sv_one_tcp() { local target="$1" port="$2" outfile="$3"; log_info "nmap -sV TCP ${target} -p ${port}"; nmap -Pn -sV -p "$port" -oN "$outfile" "$target" >/dev/null 2>&1 || true; }
run_nmap_sv_one_udp() { local target="$1" port="$2" outfile="$3"; log_info "nmap -sU -sV UDP ${target} -p ${port}"; if [ "$EUID" -ne 0 ]; then sudo nmap -Pn -sU -sV -p "$port" -oN "$outfile" "$target" >/dev/null 2>&1 || true; else nmap -Pn -sU -sV -p "$port" -oN "$outfile" "$target" >/dev/null 2>&1 || true; fi; }

# webanalyze host (domain/ip) + scheme
run_webanalyze_host() {
  local host="$1" scheme="$2" outdir="$3"
  if ! check_installed webanalyze; then log_warn "webanalyze not installed; skipping."; return 1; fi
  if [ ! -f "$WEBANALYZE_APP_JSON" ]; then log_warn "technologies.json not found at $WEBANALYZE_APP_JSON; skipping."; return 1; fi
  local url="${scheme}://${host}"
  local tag="$(sanitize "${host}_${scheme}")"
  local wa_out="$outdir/webanalyze_${tag}.txt"
  log_info "webanalyze ${url}"
  if [ "$EUID" -ne 0 ]; then sudo webanalyze -apps "$WEBANALYZE_APP_JSON" -host "$url" 2>/dev/null | tee "$wa_out" >/dev/null || true
  else webanalyze -apps "$WEBANALYZE_APP_JSON" -host "$url" 2>/dev/null | tee "$wa_out" >/dev/null || true; fi
  local flat="$outdir/webanalyze_${tag}.flat"
  flatten_webanalyze_full_versions "$wa_out" "$flat"
  if [ -s "$flat" ]; then
    local pp="80/tcp"; [ "$scheme" = "https" ] && pp="443/tcp"
    while IFS= read -r tech; do
      [ -z "$tech" ] && continue
      printf "%s %s -> %s\twebanalyze\n" "$host" "$pp" "$tech" >> "$SERVICE_FINDINGS_GLOBAL"
      log_ok "Web tech ($host $pp): $tech (webanalyze)"
    done < "$flat"
    return 0
  fi
  return 2
}

# -----------------------
# Global stores
# -----------------------
FINAL_PORTS_GLOBAL="$TMPDIR/final_ports_all.txt"; : > "$FINAL_PORTS_GLOBAL"
SERVICE_FINDINGS_GLOBAL="$TMPDIR/service_findings_all.tsv"; : > "$SERVICE_FINDINGS_GLOBAL"

# -----------------------
# Discovery + service enumeration per target
# -----------------------
while IFS= read -r TGT_RAW; do
  [ -z "$TGT_RAW" ] && continue
  TGT_NORM="$(normalize_host "$TGT_RAW")"
  TGT="$TGT_NORM"
  SAFE="$(sanitize "$TGT")"

  RAW_MASS_TCP="$TMPDIR/${SAFE}.masscan_tcp.raw"
  RAW_MASS_UDP="$TMPDIR/${SAFE}.masscan_udp.raw"
  RAW_NMAP_TCP="$TMPDIR/${SAFE}.nmap_tcp.raw"
  RAW_NMAP_UDP="$TMPDIR/${SAFE}.nmap_udp.raw"

  MASS_TCP_PORTS="$TMPDIR/${SAFE}.masscan_tcp.ports"
  MASS_UDP_PORTS="$TMPDIR/${SAFE}.masscan_udp.ports"
  NMAP_TCP_PORTS="$TMPDIR/${SAFE}.nmap_tcp.ports"
  NMAP_UDP_PORTS="$TMPDIR/${SAFE}.nmap_udp.ports"

  PARSED_TCP="$TMPDIR/${SAFE}.open_tcp.txt"
  PARSED_UDP="$TMPDIR/${SAFE}.open_udp.txt"
  FINAL_PORTS_TGT="$TMPDIR/${SAFE}.final_ports.txt"
  : > "$FINAL_PORTS_TGT"

  # ======= Discovery phase =======
  if is_hostname "$TGT"; then
    # DOMAIN/URL: masscan on resolved IPs; nmap discovery on hostname
    mapfile -t RESOLVED_IPS < <(resolve_ips_for_host "$TGT" || true)
    if [ "${#RESOLVED_IPS[@]}" -eq 0 ] || [ "${RESOLVED_IPS[0]}" = "__NO_RESOLVER__" ]; then
      if [ "${RESOLVED_IPS[0]:-}" = "__NO_RESOLVER__" ]; then
        log_warn "$TGT: No resolver tool (dig/host/getent); skipping masscan on IPs"
      else
        log_warn "$TGT: No A/AAAA records resolved; skipping masscan on IPs"
      fi
    else
      if [ "$DO_TCP" = "true" ]; then
        : > "$RAW_MASS_TCP"; : > "$MASS_TCP_PORTS"
        for ip in "${RESOLVED_IPS[@]}"; do
          ip_safe="$(sanitize "$ip")"
          raw_ip="$TMPDIR/${SAFE}.${ip_safe}.masscan_tcp.raw"
          run_masscan "$ip" "tcp" "$PORTS_TCP" "$raw_ip"
          ports_ip="$TMPDIR/${SAFE}.${ip_safe}.masscan_tcp.ports"
          parse_masscan_to_ports "$raw_ip" "$ports_ip" "masscan" "${TGT}(${ip})"
          [ -s "$raw_ip" ] && cat "$raw_ip" >> "$RAW_MASS_TCP" || true
          [ -s "$ports_ip" ] && cat "$ports_ip" >> "$MASS_TCP_PORTS" || true
        done
        [ -s "$MASS_TCP_PORTS" ] && sort -V -u "$MASS_TCP_PORTS" -o "$MASS_TCP_PORTS"
      fi
      if [ "$DO_UDP" = "true" ]; then
        : > "$RAW_MASS_UDP"; : > "$MASS_UDP_PORTS"
        for ip in "${RESOLVED_IPS[@]}"; do
          ip_safe="$(sanitize "$ip")"
          raw_ip="$TMPDIR/${SAFE}.${ip_safe}.masscan_udp.raw"
          run_masscan "$ip" "udp" "$PORTS_UDP" "$raw_ip"
          ports_ip="$TMPDIR/${SAFE}.${ip_safe}.masscan_udp.ports"
          parse_masscan_to_ports "$raw_ip" "$ports_ip" "masscan" "${TGT}(${ip})"
          [ -s "$raw_ip" ] && cat "$raw_ip" >> "$RAW_MASS_UDP" || true
          [ -s "$ports_ip" ] && cat "$ports_ip" >> "$MASS_UDP_PORTS" || true
        done
        [ -s "$MASS_UDP_PORTS" ] && sort -V -u "$MASS_UDP_PORTS" -o "$MASS_UDP_PORTS"
      fi
    fi

    # nmap discovery against the hostname (not IP)
    if [ "$DO_TCP" = "true" ]; then run_nmap_simple "$TGT" "tcp" "$PORTS_TCP" "$RAW_NMAP_TCP"; parse_nmap_ports "$RAW_NMAP_TCP" "$NMAP_TCP_PORTS" "nmap" "$TGT"; fi
    if [ "$DO_UDP" = "true" ]; then run_nmap_simple "$TGT" "udp" "$PORTS_UDP" "$RAW_NMAP_UDP"; parse_nmap_ports "$RAW_NMAP_UDP" "$NMAP_UDP_PORTS" "nmap" "$TGT"; fi

  else
    # NON-DOMAIN: original behavior (MASSCAN_FIRST switch)
    if [ "$DO_TCP" = "true" ]; then
      if [ "$MASSCAN_FIRST" = "true" ] && check_installed masscan; then
        run_masscan "$TGT" "tcp" "$PORTS_TCP" "$RAW_MASS_TCP"
        parse_masscan_to_ports "$RAW_MASS_TCP" "$MASS_TCP_PORTS" "masscan" "$TGT"
      else
        run_nmap_simple "$TGT" "tcp" "$PORTS_TCP" "$RAW_NMAP_TCP"
        parse_nmap_ports "$RAW_NMAP_TCP" "$NMAP_TCP_PORTS" "nmap" "$TGT"
      fi
    fi
    if [ "$DO_UDP" = "true" ]; then
      if [ "$MASSCAN_FIRST" = "true" ] && check_installed masscan; then
        run_masscan "$TGT" "udp" "$PORTS_UDP" "$RAW_MASS_UDP"
        parse_masscan_to_ports "$RAW_MASS_UDP" "$MASS_UDP_PORTS" "masscan" "$TGT"
        run_nmap_simple "$TGT" "udp" "$PORTS_UDP" "$RAW_NMAP_UDP"
        parse_nmap_ports "$RAW_NMAP_UDP" "$NMAP_UDP_PORTS" "nmap" "$TGT"
      else
        run_nmap_simple "$TGT" "udp" "$PORTS_UDP" "$RAW_NMAP_UDP"
        parse_nmap_ports "$RAW_NMAP_UDP" "$NMAP_UDP_PORTS" "nmap" "$TGT"
      fi
    fi
  fi

  # Merge masscan + nmap discovery (dedupe)
  : > "$PARSED_TCP"; : > "$PARSED_UDP"
  [ -s "$MASS_TCP_PORTS" ] && cat "$MASS_TCP_PORTS" >> "$PARSED_TCP"
  [ -s "$NMAP_TCP_PORTS" ] && cat "$NMAP_TCP_PORTS" >> "$PARSED_TCP"
  [ -s "$PARSED_TCP" ] && sort -V -u "$PARSED_TCP" -o "$PARSED_TCP"

  [ -s "$MASS_UDP_PORTS" ] && cat "$MASS_UDP_PORTS" >> "$PARSED_UDP"
  [ -s "$NMAP_UDP_PORTS" ] && cat "$NMAP_UDP_PORTS" >> "$PARSED_UDP"
  [ -s "$PARSED_UDP" ] && sort -V -u "$PARSED_UDP" -o "$PARSED_UDP"

  [ -s "$PARSED_TCP" ] && awk '{print $0}' "$PARSED_TCP" >> "$FINAL_PORTS_TGT"
  [ -s "$PARSED_UDP" ] && awk '{print $0}' "$PARSED_UDP" >> "$FINAL_PORTS_TGT"
  [ -s "$FINAL_PORTS_TGT" ] && sort -V -u "$FINAL_PORTS_TGT" -o "$FINAL_PORTS_TGT"

  # Append to global ports store (with target prefix)
  if [ -s "$FINAL_PORTS_TGT" ]; then
    awk -v h="$TGT" '{printf "%s %s\n", h, $0}' "$FINAL_PORTS_TGT" >> "$FINAL_PORTS_GLOBAL"
  fi

  # Print open ports for this target (unless silenced)
  if [ "$SCILENT" != "true" ]; then
    if [ -s "$FINAL_PORTS_TGT" ]; then
      echo
      echo "==== Open ports for $TGT (port/proto) ===="
      cat "$FINAL_PORTS_TGT"
    else
      log_warn "$TGT: No open ports discovered."
    fi
  fi

  # Early exit check for service/cve (per target)
  if [ "$SERVICE_SCAN_FLAG" = "true" ] && [ ! -s "$FINAL_PORTS_TGT" ]; then
    log_info "$TGT: --service-scan/--cve requested but no open ports were discovered for this target."
    continue
  fi

  # --- Service enumeration per-port (per target)
  if [ "$SERVICE_SCAN_FLAG" = "true" ]; then
    tcp_list="$(grep '/tcp$' "$FINAL_PORTS_TGT" 2>/dev/null | awk -F/ '{print $1}' | paste -sd, - || true)"
    udp_list="$(grep '/udp$' "$FINAL_PORTS_TGT" 2>/dev/null | awk -F/ '{print $1}' | paste -sd, - || true)"
    [ -z "$tcp_list" ] && [ "$DO_TCP" = "true" ] && tcp_list="$PORTS_TCP"
    [ -z "$udp_list" ] && [ "$DO_UDP" = "true" ] && udp_list="$PORTS_UDP"

    TMP_TCP_E="$TMPDIR/${SAFE}.tcp_elist.txt"
    TMP_UDP_E="$TMPDIR/${SAFE}.udp_elist.txt"
    : > "$TMP_TCP_E"; : > "$TMP_UDP_E"
    [ -n "${tcp_list:-}" ] && expand_ports "$tcp_list" > "$TMP_TCP_E"
    [ -n "${udp_list:-}" ] && expand_ports "$udp_list" > "$TMP_UDP_E"

    if [ -s "$TMP_TCP_E" ]; then
      while read -r p; do
        [ -z "$p" ] && continue
        out="$TMPDIR/${SAFE}.nmap_sV_tcp_${p}.txt"
        run_nmap_sv_one_tcp "$TGT" "$p" "$out"
        parse_nmap_services "$out" "${out}.parsed" "nmap -sV" "$TGT"
      done < "$TMP_TCP_E"
    fi

    if [ -s "$TMP_UDP_E" ]; then
      while read -r p; do
        [ -z "$p" ] && continue
        out="$TMPDIR/${SAFE}.nmap_sV_udp_${p}.txt"
        run_nmap_sv_one_udp "$TGT" "$p" "$out"
        parse_nmap_services "$out" "${out}.parsed" "nmap -sU -sV" "$TGT"
      done < "$TMP_UDP_E"
    fi
  fi
done < "$SCAN_TARGETS"

# -----------------------
# Web techs on (sub)domains
# -----------------------
if [ "$SERVICE_SCAN_FLAG" = "true" ] || [ "$CVE_FLAG" = "true" ]; then
  if awk 'NF' "$HOSTNAMES_ALL" >/dev/null 2>&1; then
    log_info "Web tech scan on domains & subdomains (http/https)"
    WEBANALYZE_OUTDIR="$TMPDIR/webanalyze"
    mkdir -p "$WEBANALYZE_OUTDIR"
    while IFS= read -r host; do
      [ -z "$host" ] && continue
      run_webanalyze_host "$host" "http"  "$WEBANALYZE_OUTDIR" || true
      run_webanalyze_host "$host" "https" "$WEBANALYZE_OUTDIR" || true
    done < "$HOSTNAMES_ALL"
  fi
fi

# -----------------------
# Final summaries (grouped by target)
# -----------------------
echo
echo "==== Port summary per target (deduped + sorted) ===="
if [ -s "$FINAL_PORTS_GLOBAL" ]; then
  awk '{print $1}' "$FINAL_PORTS_GLOBAL" | sort -u | while read -r h; do
    echo "-- $h --"
    awk -v host="$h" '$1==host{print $2}' "$FINAL_PORTS_GLOBAL" | sort -V -u
    echo
  done
else
  echo "(none)"
fi

echo "==== Services discovered per target (deduped) ===="
if [ -s "$SERVICE_FINDINGS_GLOBAL" ]; then
  awk -F'\t' '{print $1}' "$SERVICE_FINDINGS_GLOBAL" \
    | awk '{host=$1; port=$2; $1=""; $2=""; sub(/^  */,""); printf "%s %s %s\n", host, port, $0}' \
    | awk '{printf "%s %s -> %s\n", $1, $2, substr($0, index($0,$3))}' \
    | sort -V -u \
    | awk '{
        host=$1; sub(/^[^ ]+ /,"");
        if (host != last) { if (last != "") print ""; print "-- " host " --"; last=host }
        print
      }'
  echo
else
  echo "(none)"
fi

# -----------------------
# Combined open-ports output file (flat)
# -----------------------
if [ -n "$OUTFILE" ]; then
  awk '{printf "%s %s\n",$1,$2}' "$FINAL_PORTS_GLOBAL" > "$OUTFILE" 2>/dev/null || true
  [ -s "$OUTFILE" ] && log_info "final ports written to: $OUTFILE"
fi

# -----------------------
# CVE lookup (interactive) via searchsploit
# -----------------------
if [ "$CVE_FLAG" = "true" ]; then
  if ! check_installed searchsploit; then
    log_warn "searchsploit not installed — try: sudo apt install exploitdb"
    exit 0
  fi

  SERVICES_LIST="$TMPDIR/services_list.txt"; : > "$SERVICES_LIST"
  if [ -s "$SERVICE_FINDINGS_GLOBAL" ]; then
    awk -F'\t' '{print $1}' "$SERVICE_FINDINGS_GLOBAL" | sort -V -u > "$SERVICES_LIST"
  fi

  if [ ! -s "$SERVICES_LIST" ]; then
    log_warn "No services available to search for CVEs."
    exit 0
  fi

  echo
  echo "==== Select services to search for CVEs (searchsploit) ===="
  nl -w2 -s'. ' "$SERVICES_LIST"

  echo
  sel="$(prompt_read "$(printf "%s [*]%s Enter numbers (e.g., 1,3-5) to search: " "$C_INF" "$C_RST")")"
  [ -z "${sel:-}" ] && { log_warn "No selection provided. Skipping CVE search."; exit 0; }

  CHOSEN_IDX="$TMPDIR/chosen.idx"; : > "$CHOSEN_IDX"
  echo "$sel" | tr ',' '\n' | sed 's/ //g' | while read -r tok; do
    if echo "$tok" | grep -q '^-*[0-9]\+-*[0-9]\+$'; then
      a=${tok%-*}; b=${tok#*-}; [ -n "$a" ] && [ -n "$b" ] && seq "$a" "$b"
    else
      echo "$tok"
    fi
  done | awk '($1 ~ /^[0-9]+$/){print $1}' | sort -n | uniq >> "$CHOSEN_IDX"

  echo
  echo "==== CVE results (searchsploit) ===="
  while read -r idx; do
    svc_line=$(sed -n "${idx}p" "$SERVICES_LIST" 2>/dev/null || true)
    [ -z "$svc_line" ] && continue
    rhs="${svc_line#*-> }"
    rhs="$(printf "%s" "$rhs" | sed -E 's/^[[:space:]]+|[[:space:]]+$//')"
    base="$(printf "%s" "$rhs" | sed -E 's/^([A-Za-z0-9._-]+).*$/\1/')"
    [ -z "$base" ] && base="$(printf "%s" "$svc_line" | sed -E 's/^[^>]+-> *([A-Za-z0-9._-]+).*$/\1/')"
    [ -z "$base" ] && base="unknown"

    log_info "Searching: ${base} (from: \"${svc_line}\")"
    out="$TMPDIR/searchsploit_${idx}_${base}.txt"
    searchsploit "$base" 2>/dev/null | tee "$out" >/dev/null || true

    if grep -Eiq 'CVE-[0-9]{4}-[0-9]+' "$out"; then
      echo "---- CVEs for \"$base\" ----"
      grep -Ei 'CVE-[0-9]{4}-[0-9]+' "$out" | sed 's/^[[:space:]]*//'
      echo
    else
      echo "---- No explicit CVEs in titles for \"$base\"; showing top matches ----"
      awk 'NF && $0 !~ /^=+$/' "$out" | head -n 15
      echo
    fi
  done < "$CHOSEN_IDX"
fi

exit 0
